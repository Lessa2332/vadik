<!DOCTYPE html>
<html lang="uk">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <meta http-equiv="Content-Security-Policy" content="default-src 'self' https:; script-src 'self' https: 'unsafe-inline' https://cdn.jsdelivr.net https://storage.googleapis.com; style-src 'self' 'unsafe-inline'; media-src * blob: data:;">
    <title>üéÇ –ó –î–Ω–µ–º –ù–∞—Ä–æ–¥–∂–µ–Ω–Ω—è, –í–∞–¥—ñ–∫! –ü–æ—Ü—ñ–ª—É–Ω–∫–∏</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            touch-action: manipulation;
        }
       
        body {
            margin: 0;
            overflow: hidden;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            background: #000;
            color: white;
        }
       
        #video {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            object-fit: cover;
            transform: scaleX(-1);
            z-index: 1;
        }
       
        #canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 2;
            pointer-events: none;
        }
       
        #startButton {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            padding: 20px 40px;
            font-size: 24px;
            background: linear-gradient(135deg, #ff6b6b, #ff4757);
            border: none;
            border-radius: 20px;
            cursor: pointer;
            z-index: 10;
            transition: all 0.3s ease;
            color: white;
            font-weight: bold;
            box-shadow: 0 15px 40px rgba(255, 107, 107, 0.5);
            border: 3px solid rgba(255, 255, 255, 0.3);
            animation: pulse 2s infinite;
        }
       
        #title {
            position: fixed;
            top: 10%;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            font-size: clamp(24px, 5vw, 36px);
            font-weight: bold;
            text-shadow: 0 2px 10px rgba(0,0,0,0.8);
            z-index: 10;
            background: rgba(0, 0, 0, 0.6);
            padding: 15px 30px;
            border-radius: 20px;
            backdrop-filter: blur(10px);
            border: 2px solid rgba(255, 255, 255, 0.2);
            white-space: nowrap;
            display: none;
        }
       
        #loading {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #1a1a2e, #16213e);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            gap: 25px;
        }
       
        .loader {
            width: 70px;
            height: 70px;
            border: 4px solid rgba(255, 107, 107, 0.3);
            border-top: 4px solid #ff6b6b;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
       
        #smileIndicator {
            position: fixed;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(15px);
            color: white;
            padding: 12px 25px;
            border-radius: 30px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            display: none;
            align-items: center;
            gap: 12px;
            z-index: 10;
            font-size: 18px;
            font-weight: bold;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
        }
       
        .smile-icon {
            font-size: 24px;
            animation: bounce 1s infinite;
        }
       
        #debugPanel {
            position: fixed;
            top: 15px;
            right: 15px;
            background: rgba(0, 0, 0, 0.85);
            color: #4ECDC4;
            padding: 12px 15px;
            border-radius: 10px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            z-index: 50;
            border: 1px solid #4ECDC4;
            max-width: 280px;
            backdrop-filter: blur(10px);
            line-height: 1.5;
        }
       
        .debug-value { color: #FFD700; font-weight: bold; }
        .debug-good { color: #4ECDC4; }
        .debug-bad { color: #FF6B6B; }
       
        .control-btn {
            position: fixed;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.15);
            backdrop-filter: blur(15px);
            border: 2px solid rgba(255, 255, 255, 0.3);
            color: white;
            font-size: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            z-index: 10;
            transition: all 0.3s ease;
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.2);
        }
       
        .control-btn:hover { transform: scale(1.1); background: rgba(255, 255, 255, 0.25); }
       
        #soundBtn { top: 20px; left: 20px; }
        #cameraBtn { bottom: 20px; left: 20px; }
       
        .confetti {
            position: fixed;
            width: 15px;
            height: 15px;
            background: #ff6b6b;
            border-radius: 50%;
            pointer-events: none;
            z-index: 3;
            animation: confetti-fall 3s linear forwards;
        }
       
        @keyframes pulse {
            0% { transform: translate(-50%, -50%) scale(1); }
            50% { transform: translate(-50%, -50%) scale(1.05); }
            100% { transform: translate(-50%, -50%) scale(1); }
        }
       
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
       
        @keyframes bounce {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-5px); }
        }
       
        @keyframes confetti-fall {
            0% { transform: translateY(-100px) rotate(0deg); opacity: 1; }
            100% { transform: translateY(100vh) rotate(360deg); opacity: 0; }
        }
       
        @keyframes kiss-pop {
            0% { transform: scale(0); opacity: 0; }
            50% { transform: scale(1.2); opacity: 1; }
            100% { transform: scale(1); opacity: 1; }
        }
       
        @keyframes fade-in {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }
       
        @media (max-width: 768px) {
            #startButton { padding: 18px 35px; font-size: 22px; }
            #title { top: 5%; font-size: 22px; padding: 12px 20px; }
            #smileIndicator { bottom: 80px; font-size: 16px; padding: 10px 20px; }
            .control-btn { width: 45px; height: 45px; font-size: 18px; }
            #debugPanel { top: 10px; right: 10px; font-size: 11px; }
        }
    </style>
</head>
<body>
    <video id="video" playsinline muted></video>
    <canvas id="canvas"></canvas>
   
    <div id="title">üéÇ –ó –î–Ω–µ–º –ù–∞—Ä–æ–¥–∂–µ–Ω–Ω—è, –í–∞–¥—ñ–∫!</div>
    <button id="startButton">üé¨ –ü–æ—á–∞—Ç–∏ –≤–µ—Å–µ–ª–æ—â—ñ!</button>
    <div id="smileIndicator">
        <span class="smile-icon">üòä</span>
        <span id="smileText">–ü–æ—Å–º—ñ—Ö–Ω—ñ—Ç—å—Å—è –¥–ª—è –ø–æ—Ü—ñ–ª—É–Ω–∫—ñ–≤!</span>
    </div>
   
    <button id="soundBtn" class="control-btn" title="–£–≤—ñ–º–∫–Ω—É—Ç–∏/–≤–∏–º–∫–Ω—É—Ç–∏ –∑–≤—É–∫">üîä</button>
    <button id="cameraBtn" class="control-btn" title="–ü–µ—Ä–µ–º–∫–Ω—É—Ç–∏ –∫–∞–º–µ—Ä—É">üì∑</button>
   
    <div id="debugPanel">
        <div><strong>Face Tracking Debug</strong></div>
        <div>–°—Ç–∞—Ç—É—Å: <span id="debugStatus" class="debug-value">–ó–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è...</span></div>
        <div>–û–±–ª–∏—á—å: <span id="debugFaces" class="debug-value">0</span></div>
        <div>–ü–æ—Å–º—ñ—à–∫–∞: <span id="debugSmile" class="debug-value">0%</span></div>
        <div>–ü–æ—Ü—ñ–ª—É–Ω–∫–∏: <span id="debugKisses" class="debug-value">0</span></div>
    </div>
   
    <div id="loading">
        <div class="loader"></div>
        <div id="loadingText" style="font-size: 20px; text-align: center;">
            –ó–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è —Å–∏—Å—Ç–µ–º–∏ —Ä–æ–∑–ø—ñ–∑–Ω–∞–≤–∞–Ω–Ω—è –æ–±–ª–∏—á<br>
            <span style="font-size: 16px; opacity: 0.8;">–ë—É–¥—å –ª–∞—Å–∫–∞, –¥–æ–∑–≤–æ–ª—å—Ç–µ –¥–æ—Å—Ç—É–ø –¥–æ –∫–∞–º–µ—Ä–∏</span>
        </div>
    </div>
   
    <audio id="backgroundMusic" loop>
        <source src="fon.mp3" type="audio/mpeg">
    </audio>
    <audio id="kissSound" preload="auto">
        <source src="https://assets.mixkit.co/sfx/preview/mixkit-kiss-2016.mp3" type="audio/mpeg">
    </audio>

    <!-- –ü—Ä–∞–≤–∏–ª—å–Ω–∏–π –±–∞–Ω–¥–ª –∑ –æ—Ñ—ñ—Ü—ñ–π–Ω–æ—ó –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü—ñ—ó Google -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision/vision_bundle.js" crossorigin="anonymous"></script>

    <script>
        (function() {
            'use strict';
           
            const CONFIG = {
                SMILE_THRESHOLD: 0.15,
                KISS_COOLDOWN: 1000,
                KISS_OPACITY: 0.7,
                KISS_SIZE: 80,
                SMOOTHING_FACTOR: 0.7,
                TARGET_FPS: 30
            };
           
            const FACE_LANDMARKS = {
                LEFT_MOUTH: 61,
                RIGHT_MOUTH: 291,
                UPPER_LIP: 13,
                LOWER_LIP: 14,
                LEFT_CHEEK: 123,
                RIGHT_CHEEK: 352
            };
           
            const elements = {
                video: document.getElementById('video'),
                canvas: document.getElementById('canvas'),
                startButton: document.getElementById('startButton'),
                title: document.getElementById('title'),
                smileIndicator: document.getElementById('smileIndicator'),
                loading: document.getElementById('loading'),
                soundBtn: document.getElementById('soundBtn'),
                cameraBtn: document.getElementById('cameraBtn'),
                backgroundMusic: document.getElementById('backgroundMusic'),
                kissSound: document.getElementById('kissSound')
            };
           
            const ctx = elements.canvas.getContext('2d');
           
            const debug = {
                status: document.getElementById('debugStatus'),
                faces: document.getElementById('debugFaces'),
                smile: document.getElementById('debugSmile'),
                kisses: document.getElementById('debugKisses')
            };
           
            const state = {
                isRunning: false,
                isFrontCamera: true,
                isSoundOn: true,
                faceLandmarker: null,
                videoStream: null,
                animationFrameId: null,
                lastSmileTime: 0,
                kissCount: 0,
                lastRenderTime: 0,
                smileLevel: 0,
                lastSmileLevel: 0,
                activeKisses: [],
                confetti: [],
                stats: {
                    totalKisses: 0
                }
            };
           
            function createKissImage(size, color = '#ff6b6b') {
                const canvas = document.createElement('canvas');
                canvas.width = size;
                canvas.height = size;
                const ctx = canvas.getContext('2d');
               
                ctx.fillStyle = color;
                ctx.globalAlpha = CONFIG.KISS_OPACITY;
               
                ctx.beginPath();
                ctx.ellipse(size/2, size/3, size/3, size/4, 0, 0, Math.PI * 2);
                ctx.fill();
               
                ctx.beginPath();
                ctx.ellipse(size/2, size/1.8, size/2.5, size/3.5, 0, 0, Math.PI * 2);
                ctx.fill();
               
                ctx.globalAlpha = 0.3;
                ctx.fillStyle = '#ff4757';
                for (let i = 0; i < 50; i++) {
                    const x = Math.random() * size;
                    const y = Math.random() * size;
                    const radius = Math.random() * 3;
                    ctx.beginPath();
                    ctx.arc(x, y, radius, 0, Math.PI * 2);
                    ctx.fill();
                }
               
                return canvas;
            }
           
            const kissImage = createKissImage(CONFIG.KISS_SIZE, '#ff6b6b');
           
            class KissARApp {
                constructor() {
                    this.init();
                }
               
                async init() {
                    try {
                        this.setupEventListeners();
                        await this.setupCamera();
                        await this.initFaceTracking();
                        this.setupCanvas();
                        this.hideLoading();
                        this.startRenderLoop();
                        debug.status.textContent = '‚úÖ –ì–æ—Ç–æ–≤–æ';
                        debug.status.className = 'debug-value debug-good';
                    } catch (error) {
                        this.handleError(error);
                    }
                }
               
                async setupCamera() {
                    try {
                        const constraints = {
                            video: {
                                facingMode: 'user',
                                width: { ideal: 1280 },
                                height: { ideal: 720 },
                                frameRate: { ideal: 30 }
                            }
                        };
                       
                        const stream = await navigator.mediaDevices.getUserMedia(constraints);
                        elements.video.srcObject = stream;
                        state.videoStream = stream;
                       
                        await new Promise((resolve) => {
                            elements.video.onloadedmetadata = () => {
                                elements.video.play();
                                resolve();
                            };
                        });
                       
                    } catch (error) {
                        console.error('–ü–æ–º–∏–ª–∫–∞ –∫–∞–º–µ—Ä–∏:', error);
                        throw new Error('CAMERA_ERROR');
                    }
                }
               
                async switchCamera() {
                    if (!state.videoStream) return;
                   
                    state.videoStream.getTracks().forEach(track => track.stop());
                   
                    state.isFrontCamera = !state.isFrontCamera;
                    const facingMode = state.isFrontCamera ? 'user' : 'environment';
                   
                    try {
                        const constraints = {
                            video: {
                                facingMode: facingMode,
                                width: { ideal: 1280 },
                                height: { ideal: 720 },
                                frameRate: { ideal: 30 }
                            }
                        };
                       
                        const stream = await navigator.mediaDevices.getUserMedia(constraints);
                        elements.video.srcObject = stream;
                        state.videoStream = stream;
                       
                        elements.video.style.transform = state.isFrontCamera ? 'scaleX(-1)' : 'scaleX(1)';
                       
                    } catch (error) {
                        console.error('–ü–æ–º–∏–ª–∫–∞ –ø–µ—Ä–µ–º–∏–∫–∞–Ω–Ω—è –∫–∞–º–µ—Ä–∏:', error);
                        state.isFrontCamera = !state.isFrontCamera;
                    }
                }
               
                async initFaceTracking() {
                    try {
                        debug.status.textContent = '–ó–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è MediaPipe...';
                        debug.status.className = 'debug-value';
                       
                        const { FilesetResolver, FaceLandmarker } = mp.tasks.vision;
                       
                        const vision = await FilesetResolver.forVisionTasks(
                            "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision/wasm"
                        );
                       
                        state.faceLandmarker = await FaceLandmarker.createFromOptions(vision, {
                            baseOptions: {
                                modelAssetPath: "https://storage.googleapis.com/mediapipe-models/face_landmarker/face_landmarker/float16/1/face_landmarker.task",
                                delegate: "GPU"
                            },
                            outputFaceBlendshapes: true,
                            runningMode: "VIDEO",
                            numFaces: 1
                        });
                       
                        debug.status.textContent = '‚úÖ Face Tracking';
                        debug.status.className = 'debug-value debug-good';
                    } catch (error) {
                        console.error('–ü–æ–º–∏–ª–∫–∞ MediaPipe:', error);
                        debug.status.textContent = '‚ùå –ü–æ–º–∏–ª–∫–∞';
                        debug.status.className = 'debug-value debug-bad';
                        throw error;
                    }
                }
               
                detectFace() {
                    if (!state.faceLandmarker || !state.isRunning) return;
                   
                    try {
                        if (elements.video.readyState < 2) return;
                       
                        const results = state.faceLandmarker.detectForVideo(elements.video, performance.now());
                       
                        if (results.faceLandmarks && results.faceLandmarks.length > 0) {
                            debug.faces.textContent = '1';
                            debug.faces.className = 'debug-value debug-good';
                           
                            const landmarks = results.faceLandmarks[0];
                            const blendshapes = results.faceBlendshapes?.[0]?.categories || [];
                           
                            this.analyzeSmile(landmarks, blendshapes);
                           
                        } else {
                            debug.faces.textContent = '0';
                            debug.faces.className = 'debug-value debug-bad';
                            this.hideSmileIndicator();
                        }
                    } catch (error) {
                        console.error('–ü–æ–º–∏–ª–∫–∞ –¥–µ—Ç–µ–∫—Ü—ñ—ó:', error);
                    }
                }
               
                analyzeSmile(landmarks, blendshapes) {
                    let smileScore = 0;
                   
                    const mouthSmileLeft = blendshapes.find(b => b.categoryName === 'mouthSmileLeft');
                    const mouthSmileRight = blendshapes.find(b => b.categoryName === 'mouthSmileRight');
                       
                    if (mouthSmileLeft && mouthSmileRight) {
                        smileScore = (mouthSmileLeft.score + mouthSmileRight.score) / 2;
                    }
                   
                    if (smileScore < 0.1 && landmarks.length > 400) {
                        const leftMouth = landmarks[FACE_LANDMARKS.LEFT_MOUTH];
                        const rightMouth = landmarks[FACE_LANDMARKS.RIGHT_MOUTH];
                        const upperLip = landmarks[FACE_LANDMARKS.UPPER_LIP];
                        const lowerLip = landmarks[FACE_LANDMARKS.LOWER_LIP];
                       
                        if (leftMouth && rightMouth && upperLip && lowerLip) {
                            const mouthWidth = Math.abs(rightMouth.x - leftMouth.x);
                            const mouthHeight = Math.abs(lowerLip.y - upperLip.y);
                            const ratio = mouthHeight / mouthWidth;
                            smileScore = Math.max(0, 1 - (ratio * 3));
                        }
                    }
                   
                    state.smileLevel = state.lastSmileLevel * (1 - CONFIG.SMOOTHING_FACTOR) + smileScore * CONFIG.SMOOTHING_FACTOR;
                    state.lastSmileLevel = state.smileLevel;
                   
                    const smilePercent = Math.round(state.smileLevel * 100);
                    debug.smile.textContent = `${smilePercent}%`;
                    debug.smile.className = smilePercent > 20 ? 'debug-value debug-good' : 'debug-value';
                   
                    if (state.smileLevel > CONFIG.SMILE_THRESHOLD) {
                        this.showSmileIndicator(smilePercent);
                       
                        const now = Date.now();
                        if (now - state.lastSmileTime > CONFIG.KISS_COOLDOWN) {
                            this.addKisses(landmarks);
                            state.lastSmileTime = now;
                        }
                    } else {
                        this.hideSmileIndicator();
                    }
                }
               
                addKisses(landmarks) {
                    if (landmarks.length < 400) return;
                   
                    const leftCheek = landmarks[FACE_LANDMARKS.LEFT_CHEEK];
                    const rightCheek = landmarks[FACE_LANDMARKS.RIGHT_CHEEK];
                   
                    if (!leftCheek || !rightCheek) return;
                   
                    const videoWidth = elements.video.videoWidth || elements.video.clientWidth;
                    const videoHeight = elements.video.videoHeight || elements.video.clientHeight;
                    const canvasWidth = elements.canvas.width;
                    const canvasHeight = elements.canvas.height;
                   
                    const leftX = (state.isFrontCamera ? (1 - leftCheek.x) : leftCheek.x) * videoWidth * (canvasWidth / videoWidth);
                    const leftY = leftCheek.y * videoHeight * (canvasHeight / videoHeight);
                   
                    const rightX = (state.isFrontCamera ? (1 - rightCheek.x) : rightCheek.x) * videoWidth * (canvasWidth / videoWidth);
                    const rightY = rightCheek.y * videoHeight * (canvasHeight / videoHeight);
                   
                    const kisses = [
                        { x: leftX, y: leftY, size: CONFIG.KISS_SIZE * (0.8 + Math.random() * 0.4), rotation: Math.random() * Math.PI * 2, opacity: CONFIG.KISS_OPACITY, life: 1.0, decay: 0.01 + Math.random() * 0.02 },
                        { x: rightX, y: rightY, size: CONFIG.KISS_SIZE * (0.8 + Math.random() * 0.4), rotation: Math.random() * Math.PI * 2, opacity: CONFIG.KISS_OPACITY, life: 1.0, decay: 0.01 + Math.random() * 0.02 }
                    ];
                   
                    state.activeKisses.push(...kisses);
                    state.stats.totalKisses += 2;
                    debug.kisses.textContent = state.stats.totalKisses;
                   
                    this.playKissSound();
                    this.createConfetti(leftX, leftY);
                    this.createConfetti(rightX, rightY);
                }
               
                updateKisses() {
                    for (let i = state.activeKisses.length - 1; i >= 0; i--) {
                        const kiss = state.activeKisses[i];
                        kiss.life -= kiss.decay;
                        kiss.opacity = CONFIG.KISS_OPACITY * kiss.life;
                       
                        if (kiss.life <= 0) {
                            state.activeKisses.splice(i, 1);
                            continue;
                        }
                       
                        ctx.save();
                        ctx.translate(kiss.x, kiss.y);
                        ctx.rotate(kiss.rotation);
                        ctx.globalAlpha = kiss.opacity;
                        ctx.drawImage(kissImage, -kiss.size / 2, -kiss.size / 2, kiss.size, kiss.size);
                        ctx.globalAlpha = kiss.opacity * 0.3;
                        ctx.fillStyle = '#ff6b6b';
                        ctx.beginPath();
                        ctx.arc(0, 0, kiss.size / 1.5, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.restore();
                    }
                }
               
                createConfetti(x, y) {
                    for (let i = 0; i < 15; i++) {
                        state.confetti.push({
                            x, y,
                            vx: (Math.random() - 0.5) * 10,
                            vy: Math.random() * -15 - 5,
                            size: Math.random() * 8 + 4,
                            color: `hsl(${Math.random() * 60 + 300}, 100%, 65%)`,
                            life: 1.0,
                            gravity: 0.4,
                            rotation: Math.random() * Math.PI * 2,
                            spin: (Math.random() - 0.5) * 0.3
                        });
                    }
                }
               
                updateConfetti() {
                    for (let i = state.confetti.length - 1; i >= 0; i--) {
                        const p = state.confetti[i];
                        p.vy += p.gravity;
                        p.x += p.vx;
                        p.y += p.vy;
                        p.life -= 0.015;
                        p.rotation += p.spin;
                       
                        if (p.life <= 0) {
                            state.confetti.splice(i, 1);
                            continue;
                        }
                       
                        ctx.save();
                        ctx.globalAlpha = p.life;
                        ctx.translate(p.x, p.y);
                        ctx.rotate(p.rotation);
                        ctx.fillStyle = p.color;
                        ctx.fillRect(-p.size/2, -p.size/2, p.size, p.size);
                        ctx.restore();
                    }
                }
               
                playKissSound() {
                    if (!state.isSoundOn) return;
                    elements.kissSound.currentTime = 0;
                    elements.kissSound.play().catch(() => {});
                }
               
                toggleSound() {
                    state.isSoundOn = !state.isSoundOn;
                    if (state.isSoundOn) {
                        elements.backgroundMusic.play().catch(() => {
                            elements.backgroundMusic.src = 'https://assets.mixkit.co/music/preview/mixkit-clear-sky-479.mp3';
                            elements.backgroundMusic.play().catch(() => {});
                        });
                        elements.soundBtn.textContent = 'üîä';
                    } else {
                        elements.backgroundMusic.pause();
                        elements.soundBtn.textContent = 'üîá';
                    }
                }
               
                showSmileIndicator(percent) {
                    const text = percent > 50 ? '–ß—É–¥–æ–≤–∞ –ø–æ—Å–º—ñ—à–∫–∞! üíã' : percent > 30 ? '–¢—Ä–∏–º–∞–π—Ç–µ –ø–æ—Å–º—ñ—à–∫—É! üòä' : '–ü–æ—Å–º—ñ—Ö–Ω—ñ—Ç—å—Å—è —Å–∏–ª—å–Ω—ñ—à–µ!';
                    document.getElementById('smileText').textContent = text;
                    elements.smileIndicator.style.display = 'flex';
                }
               
                hideSmileIndicator() {
                    elements.smileIndicator.style.display = 'none';
                }
               
                hideLoading() {
                    elements.loading.style.display = 'none';
                    elements.startButton.style.display = 'none';
                    elements.title.style.display = 'block';
                    state.isRunning = true;
                    if (state.isSoundOn) this.toggleSound();
                }
               
                setupCanvas() {
                    elements.canvas.width = window.innerWidth;
                    elements.canvas.height = window.innerHeight;
                    window.addEventListener('resize', () => {
                        elements.canvas.width = window.innerWidth;
                        elements.canvas.height = window.innerHeight;
                    });
                }
               
                clearCanvas() {
                    ctx.clearRect(0, 0, elements.canvas.width, elements.canvas.height);
                }
               
                startRenderLoop() {
                    const render = (currentTime) => {
                        if (currentTime - state.lastRenderTime >= 1000 / CONFIG.TARGET_FPS) {
                            if (state.isRunning) {
                                this.clearCanvas();
                                this.detectFace();
                                this.updateKisses();
                                this.updateConfetti();
                            }
                            state.lastRenderTime = currentTime;
                        }
                        state.animationFrameId = requestAnimationFrame(render);
                    };
                    render(performance.now());
                }
               
                setupEventListeners() {
                    elements.startButton.addEventListener('click', () => this.hideLoading());
                    elements.soundBtn.addEventListener('click', () => this.toggleSound());
                    elements.cameraBtn.addEventListener('click', () => this.switchCamera());
                    document.addEventListener('click', () => {
                        if (state.isSoundOn && elements.backgroundMusic.paused) {
                            elements.backgroundMusic.play().catch(() => {});
                        }
                    }, { once: true });
                }
               
                handleError(error) {
                    console.error('–ü–æ–º–∏–ª–∫–∞ –¥–æ–¥–∞—Ç–∫—É:', error);
                    let message = '–ù–µ–≤—ñ–¥–æ–º–∞ –ø–æ–º–∏–ª–∫–∞';
                    let details = '';
                    if (error.message === 'CAMERA_ERROR') {
                        message = '–ü–æ–º–∏–ª–∫–∞ –¥–æ—Å—Ç—É–ø—É –¥–æ –∫–∞–º–µ—Ä–∏';
                        details = '–î–æ–∑–≤–æ–ª—å—Ç–µ –¥–æ—Å—Ç—É–ø –¥–æ –∫–∞–º–µ—Ä–∏';
                    } else {
                        message = '–ü–æ–º–∏–ª–∫–∞ –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è';
                        details = '–û–Ω–æ–≤—ñ—Ç—å —Å—Ç–æ—Ä—ñ–Ω–∫—É –∞–±–æ –ø–µ—Ä–µ–≤—ñ—Ä—Ç–µ —ñ–Ω—Ç–µ—Ä–Ω–µ—Ç';
                    }
                    elements.loading.innerHTML = `
                        <div style="color: #ff4757; font-size: 24px; margin-bottom: 15px;">${message}</div>
                        <div style="color: white; font-size: 16px; margin-bottom: 20px;">${details}</div>
                        <button onclick="location.reload()" style="padding: 12px 24px; background: linear-gradient(135deg, #ff6b6b, #ff4757); border: none; color: white; font-size: 16px; cursor: pointer; border-radius: 25px;">–°–ø—Ä–æ–±—É–≤–∞—Ç–∏ –∑–Ω–æ–≤—É</button>
                    `;
                }
               
                cleanup() {
                    if (state.animationFrameId) cancelAnimationFrame(state.animationFrameId);
                    if (state.videoStream) state.videoStream.getTracks().forEach(t => t.stop());
                    if (state.faceLandmarker) state.faceLandmarker.close();
                }
            }
           
            window.addEventListener('DOMContentLoaded', () => {
                if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                    elements.loading.innerHTML = `<div style="color: #ff4757;">–ë—Ä–∞—É–∑–µ—Ä –Ω–µ –ø—ñ–¥—Ç—Ä–∏–º—É—î –∫–∞–º–µ—Ä—É</div><div>–°–ø—Ä–æ–±—É–π—Ç–µ Chrome –∞–±–æ Safari</div>`;
                    return;
                }
                const app = new KissARApp();
                window.addEventListener('beforeunload', () => app.cleanup());
            });
        })();
    </script>
</body>
</html>
